import Mathlib.Algebra.Group.Subgroup.Defs
import Mathlib.Data.Int.Basic
import Mathlib.Data.Fintype.Defs
import Mathlib.Data.Set.Lattice

namespace Question5

universe u

variable {G : Type u} [Group G]

/-- Incomplete transfer/indexing system on the subgroup lattice of `G`. -/
structure IncompleteTransferSystem (G : Type u) [Group G] where
  transfer : Subgroup G → Subgroup G → Prop
  transfer_refl : ∀ H, transfer H H
  transfer_trans : ∀ {H K L}, transfer H K → transfer K L → transfer H L
  transfer_subgroup : ∀ {H K}, transfer H K → H ≤ K

/-- Dimension threshold depending on transfer system, subgroup, and slice level. -/
abbrev DimensionFunction (G : Type u) [Group G] :=
  IncompleteTransferSystem G → Subgroup G → ℤ → ℤ

/-- Optional monotonicity contract for the dimension function. -/
structure DimensionFunctionSpec (d : DimensionFunction G) : Prop where
  transfer_mono : ∀ {O H K n}, O.transfer H K → d O H n ≤ d O K n

/-- `N∞` operad interface via associated incomplete transfer system. -/
structure NInfinityOperad (G : Type u) [Group G] where
  transferSystem : IncompleteTransferSystem G

/--
Indexing system packaged on top of an incomplete transfer system.
We record two closure properties typical for admissible-transfer formalisms.
-/
structure IndexingSystem (G : Type u) [Group G] where
  toTransferSystem : IncompleteTransferSystem G
  closed_downward :
    ∀ {H K L : Subgroup G}, toTransferSystem.transfer H K → L ≤ H →
      toTransferSystem.transfer L K
  closed_upward :
    ∀ {H K L : Subgroup G}, toTransferSystem.transfer H K → K ≤ L →
      toTransferSystem.transfer H L

/-- Abstract slice-cell data (`G₊ ∧_H S^V` compressed to subgroup pair + degree). -/
structure SliceCellData (G : Type u) [Group G] where
  fromSubgroup : Subgroup G
  toSubgroup : Subgroup G
  degree : ℤ

abbrev SpectrumObj (G : Type u) [Group G] := Set (SliceCellData G)

/--
`O`-admissible slice cells at level `n`.
The degree condition is imposed at the source subgroup of the cell.
-/
def IsOSliceCell (O : IncompleteTransferSystem G) (d : DimensionFunction G)
    (n : ℤ) (c : SliceCellData G) : Prop :=
  O.transfer c.fromSubgroup c.toSubgroup ∧
    d O c.fromSubgroup n ≤ c.degree ∧
      0 ≤ c.degree

def OSliceCells (O : IncompleteTransferSystem G) (d : DimensionFunction G)
    (n : ℤ) : Set (SliceCellData G) :=
  {c | IsOSliceCell O d n c}

/-- Generator objects for level-`n` slice filtration: singleton cells from `OSliceCells`. -/
def SliceGenerators (O : IncompleteTransferSystem G) (d : DimensionFunction G)
    (n : ℤ) : Set (SpectrumObj G) :=
  {X | ∃ c, c ∈ OSliceCells O d n ∧ X = ({c} : Set (SliceCellData G))}

/--
Localizing closure on the concrete model:
`zero`, `susp` (identity in this toy stable model), `cofiber` (union), and small colimits (`⋃`).
-/
inductive InLocalizing (S : Set (SpectrumObj G)) : SpectrumObj G → Prop
  | of_generator {X} : X ∈ S → InLocalizing S X
  | zero : InLocalizing S (∅ : SpectrumObj G)
  | susp {X} : InLocalizing S X → InLocalizing S X
  | cofiber {X Y} : InLocalizing S X → InLocalizing S Y → InLocalizing S (X ∪ Y)
  | colim {ι : Type u} (F : ι → SpectrumObj G) :
      (∀ i, InLocalizing S (F i)) → InLocalizing S (⋃ i, F i)

/-- `O`-slice connectivity via localizing subcategory generated by admissible slice cells. -/
def OSliceConnectivity (O : IncompleteTransferSystem G) (d : DimensionFunction G)
    (n : ℤ) (X : SpectrumObj G) : Prop :=
  InLocalizing (SliceGenerators O d n) X

/-- Level-`n` `O`-slice filtration. -/
def OSliceFiltration (O : IncompleteTransferSystem G) (d : DimensionFunction G)
    (n : ℤ) : Set (SpectrumObj G) :=
  {X | OSliceConnectivity O d n X}

def OperadSliceFiltration (Oinf : NInfinityOperad G) (d : DimensionFunction G)
    (n : ℤ) : Set (SpectrumObj G) :=
  OSliceFiltration Oinf.transferSystem d n

theorem mem_oSliceFiltration_iff (O : IncompleteTransferSystem G) (d : DimensionFunction G)
    (n : ℤ) (X : SpectrumObj G) :
    X ∈ OSliceFiltration O d n ↔ OSliceConnectivity O d n X := by
  rfl

theorem mem_operadSliceFiltration_iff (Oinf : NInfinityOperad G) (d : DimensionFunction G)
    (n : ℤ) (X : SpectrumObj G) :
    X ∈ OperadSliceFiltration Oinf d n ↔ OSliceConnectivity Oinf.transferSystem d n X := by
  rfl

/-- Geometric fixed-point functor in the concrete cell model. -/
def GeometricFixedPoints (O : IncompleteTransferSystem G) (H : Subgroup G)
    (X : SpectrumObj G) : SpectrumObj G :=
  {c | c ∈ X ∧ O.transfer H c.fromSubgroup}

/-- Connectedness condition at subgroup `H` and threshold `d O H n`. -/
def GeoConnectedAt (O : IncompleteTransferSystem G) (d : DimensionFunction G)
    (n : ℤ) (H : Subgroup G) (Y : SpectrumObj G) : Prop :=
  ∀ c, c ∈ Y → O.transfer c.fromSubgroup c.toSubgroup ∧ d O H n ≤ c.degree

/-- Global geometric fixed-point criterion at level `n`. -/
def GeometricFixedPointCondition (O : IncompleteTransferSystem G) (d : DimensionFunction G)
    (n : ℤ) (X : SpectrumObj G) : Prop :=
  ∀ H, GeoConnectedAt O d n H (GeometricFixedPoints O H X)

def IsConnective (X : SpectrumObj G) : Prop :=
  ∀ c, c ∈ X → 0 ≤ c.degree

lemma geoCondition_of_generator (O : IncompleteTransferSystem G) (d : DimensionFunction G)
    (hSpec : DimensionFunctionSpec d) (n : ℤ) {c : SliceCellData G}
    (hc : IsOSliceCell O d n c) :
    GeometricFixedPointCondition O d n ({c} : SpectrumObj G) := by
  intro H c' hc'
  rcases hc' with ⟨hcset, htrans⟩
  have hcEq : c' = c := by simpa using hcset
  have hBoundH : d O H n ≤ d O c'.fromSubgroup n :=
    hSpec.transfer_mono htrans
  have hTransfer : O.transfer c'.fromSubgroup c'.toSubgroup := by
    simpa [hcEq] using hc.1
  have hBoundFrom : d O c'.fromSubgroup n ≤ c'.degree := by
    simpa [hcEq] using hc.2.1
  exact ⟨hTransfer, le_trans hBoundH hBoundFrom⟩

lemma geoCondition_zero (O : IncompleteTransferSystem G) (d : DimensionFunction G) (n : ℤ) :
    GeometricFixedPointCondition O d n (∅ : SpectrumObj G) := by
  intro H c hc
  exact False.elim (Set.notMem_empty c hc.1)

lemma geoCondition_susp {O : IncompleteTransferSystem G} {d : DimensionFunction G}
    {n : ℤ} {X : SpectrumObj G} (hX : GeometricFixedPointCondition O d n X) :
    GeometricFixedPointCondition O d n X := by
  exact hX

lemma geoCondition_cofiber {O : IncompleteTransferSystem G} {d : DimensionFunction G}
    {n : ℤ} {X Y : SpectrumObj G}
    (hX : GeometricFixedPointCondition O d n X)
    (hY : GeometricFixedPointCondition O d n Y) :
    GeometricFixedPointCondition O d n (X ∪ Y) := by
  intro H c hc
  rcases hc with ⟨hcXY, htrans⟩
  rcases hcXY with hcX | hcY
  · exact hX H c ⟨hcX, htrans⟩
  · exact hY H c ⟨hcY, htrans⟩

lemma geoCondition_colim {O : IncompleteTransferSystem G} {d : DimensionFunction G}
    {n : ℤ} {ι : Type u} (F : ι → SpectrumObj G)
    (hF : ∀ i, GeometricFixedPointCondition O d n (F i)) :
    GeometricFixedPointCondition O d n (⋃ i, F i) := by
  intro H c hc
  rcases hc with ⟨hcUnion, htrans⟩
  rcases Set.mem_iUnion.mp hcUnion with ⟨i, hci⟩
  exact hF i H c ⟨hci, htrans⟩

lemma oSliceConnectivity_implies_geometricFixedPoints
    (O : IncompleteTransferSystem G) (d : DimensionFunction G)
    (hSpec : DimensionFunctionSpec d) (n : ℤ)
    {X : SpectrumObj G} (hX : OSliceConnectivity O d n X) :
    GeometricFixedPointCondition O d n X := by
  unfold OSliceConnectivity at hX
  induction hX with
  | of_generator hGen =>
      rcases hGen with ⟨c, hc, rfl⟩
      exact geoCondition_of_generator O d hSpec n hc
  | zero =>
      exact geoCondition_zero O d n
  | susp hMem ih =>
      exact geoCondition_susp ih
  | cofiber hA hB ihA ihB =>
      exact geoCondition_cofiber ihA ihB
  | colim F hFam ih =>
      exact geoCondition_colim F ih

lemma oSliceConnectivity_implies_connective
    (O : IncompleteTransferSystem G) (d : DimensionFunction G) (n : ℤ)
    {X : SpectrumObj G} (hX : OSliceConnectivity O d n X) :
    IsConnective X := by
  unfold OSliceConnectivity at hX
  induction hX with
  | of_generator hGen =>
      rcases hGen with ⟨c, hc, rfl⟩
      intro c' hc'
      have hcEq : c' = c := by simpa using hc'
      simpa [hcEq] using hc.2.2
  | zero =>
      intro c hc
      exact False.elim (Set.notMem_empty c hc)
  | susp hMem ih =>
      exact ih
  | cofiber hA hB ihA ihB =>
      intro c hc
      rcases hc with hcA | hcB
      · exact ihA c hcA
      · exact ihB c hcB
  | colim F hFam ih =>
      intro c hc
      rcases Set.mem_iUnion.mp hc with ⟨i, hci⟩
      exact ih i c hci

lemma cell_is_oSliceCell_of_geometricFixedPoints
    {O : IncompleteTransferSystem G} {d : DimensionFunction G} {n : ℤ}
    {X : SpectrumObj G} {c : SliceCellData G}
    (hConn : IsConnective X)
    (hGeo : GeometricFixedPointCondition O d n X) (hcX : c ∈ X) :
    IsOSliceCell O d n c := by
  have hAtFrom := hGeo c.fromSubgroup
  have hmemFrom : c ∈ GeometricFixedPoints O c.fromSubgroup X := by
    exact ⟨hcX, O.transfer_refl c.fromSubgroup⟩
  have hFromInfo := hAtFrom c hmemFrom
  constructor
  · exact hFromInfo.1
  · constructor
    · exact hFromInfo.2
    · exact hConn c hcX

lemma geometricFixedPoints_implies_oSliceConnectivity
    {O : IncompleteTransferSystem G} {d : DimensionFunction G} {n : ℤ}
    {X : SpectrumObj G} (hConn : IsConnective X)
    (hGeo : GeometricFixedPointCondition O d n X) :
    OSliceConnectivity O d n X := by
  let ι : Type u := {c : SliceCellData G // c ∈ X}
  let F : ι → SpectrumObj G := fun i => ({i.1} : Set (SliceCellData G))
  have hF : ∀ i, InLocalizing (SliceGenerators O d n) (F i) := by
    intro i
    have hc : IsOSliceCell O d n i.1 :=
      cell_is_oSliceCell_of_geometricFixedPoints hConn hGeo i.2
    apply InLocalizing.of_generator
    exact ⟨i.1, hc, rfl⟩
  have hColim : InLocalizing (SliceGenerators O d n) (⋃ i, F i) :=
    InLocalizing.colim F hF
  have hEq : (⋃ i, F i) = X := by
    ext c
    constructor
    · intro hcUnion
      rcases Set.mem_iUnion.mp hcUnion with ⟨i, hci⟩
      have hEqc : c = i.1 := by simpa [F] using hci
      exact hEqc ▸ i.2
    · intro hcX
      refine Set.mem_iUnion.mpr ?_
      refine ⟨⟨c, hcX⟩, ?_⟩
      simp [F]
  unfold OSliceConnectivity
  simp [hEq] at hColim
  exact hColim

/--
Characterization theorem:
for connective objects, `O`-slice connectivity (generated/localizing definition)
is equivalent to geometric fixed-point connectivity constraints.
-/
theorem oSliceConnectivity_iff_geometricFixedPoints [Fintype G]
    (O : IncompleteTransferSystem G) (d : DimensionFunction G)
    (hSpec : DimensionFunctionSpec d)
    (X : SpectrumObj G) (n : ℤ) (_hConn : IsConnective X) :
    OSliceConnectivity O d n X ↔ GeometricFixedPointCondition O d n X := by
  constructor
  · intro hSlice
    exact oSliceConnectivity_implies_geometricFixedPoints O d hSpec n hSlice
  · intro hGeo
    exact geometricFixedPoints_implies_oSliceConnectivity _hConn hGeo

theorem operad_sliceConnectivity_iff_geometricFixedPoints [Fintype G]
    (Oinf : NInfinityOperad G) (d : DimensionFunction G)
    (hSpec : DimensionFunctionSpec d)
    (X : SpectrumObj G) (n : ℤ) (_hConn : IsConnective X) :
    OSliceConnectivity Oinf.transferSystem d n X ↔
      GeometricFixedPointCondition Oinf.transferSystem d n X := by
  exact oSliceConnectivity_iff_geometricFixedPoints Oinf.transferSystem d hSpec X n _hConn

theorem indexingSystem_sliceConnectivity_iff_geometricFixedPoints [Fintype G]
    (I : IndexingSystem G) (d : DimensionFunction G)
    (hSpec : DimensionFunctionSpec d)
    (X : SpectrumObj G) (n : ℤ) (_hConn : IsConnective X) :
    OSliceConnectivity I.toTransferSystem d n X ↔
      GeometricFixedPointCondition I.toTransferSystem d n X := by
  exact oSliceConnectivity_iff_geometricFixedPoints I.toTransferSystem d hSpec X n _hConn

end Question5
